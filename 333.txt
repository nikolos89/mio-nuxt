—Ä–∞–±–æ—Ç–∞–µ—Ç –æ—á–µ–Ω—å –º–Ω–æ–≥–æ, —á–∞—Ç—ã –æ–±—â–∏–µ –Ω–∞ –≤—Å–µ—Ö —Å–µ–π—á–∞—Å.


–ø—Ä–∏–≤–µ—Ç.

–Ω–µ —Ç—Ä–æ–≥–∞–π –ª–∏—à–Ω–µ–≥–æ, —Ç–æ –æ —á—ë–º —è –Ω–µ –ø—Ä–æ—Å–∏–ª.

—Ü–µ–ª—å:
—Å–¥–µ–ª–∞—Ç—å —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–º–∏, –∏ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å–∏—Å—Ç–µ–º—ã.

–¥–µ–ª–∞—é –Ω–∞ nuxt, –≤ —Å–≤—è–∑–∫–µ —Ü–µ–Ω—Ç—Ä–∏—Ñ—É–≥–æ, –∏ —Ä–µ–¥–∏—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.

—Ñ–∞–π–ª—ã:

useAuth.ts
interface User {
  phone: string;
  id: string;
}

export const useAuth = () => {
  const user = ref<User | null>(null);
  const isAuthenticated = computed(() => !!user.value);

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ - –§–ò–ö–°–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
  const initAuth = () => {
    if (process.client) {
      const savedUser = localStorage.getItem("chat-user");
      console.log("üîÑ Auth init - localStorage chat-user:", savedUser);
      if (savedUser) {
        try {
          user.value = JSON.parse(savedUser);
          console.log("‚úÖ Auth initialized with user:", user.value);
        } catch (error) {
          console.error("‚ùå Failed to parse saved user:", error);
          localStorage.removeItem("chat-user");
        }
      } else {
        console.log("‚ÑπÔ∏è No saved user found in localStorage");
      }
    }
  };

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
  const checkAuth = (): boolean => {
    if (process.client) {
      const savedUser = localStorage.getItem("chat-user");
      if (savedUser && !user.value) {
        try {
          user.value = JSON.parse(savedUser);
          console.log("‚úÖ Auth checked and user restored:", user.value);
          return true;
        } catch (error) {
          console.error("‚ùå Failed to parse user during check:", error);
          return false;
        }
      }
    }
    return !!user.value;
  };

  // –í—Ö–æ–¥ - –∑–∞–ø—Ä–æ—Å –∫–æ–¥–∞
  const login = async (
    phone: string
  ): Promise<{ success: boolean; message: string }> => {
    try {
      const data = await $fetch("/api/auth/login", {
        method: "POST",
        body: { phone },
      });

      return {
        success: data.success,
        message: data.message || "–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω",
      };
    } catch (error: any) {
      console.error("Login error:", error);
      return {
        success: false,
        message: error.data?.message || "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞",
      };
    }
  };

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞
  const verify = async (
    phone: string,
    code: string
  ): Promise<{ success: boolean; user?: User; message: string }> => {
    try {
      const data = await $fetch("/api/auth/verify", {
        method: "POST",
        body: { phone, code },
      });

      if (data.success && data.user) {
        user.value = data.user;
        if (process.client) {
          localStorage.setItem("chat-user", JSON.stringify(data.user));
          localStorage.setItem("chat-user-id", data.user.id);
        }
        console.log("‚úÖ User verified and saved:", data.user);
        return {
          success: true,
          user: data.user,
          message: "–£—Å–ø–µ—à–Ω—ã–π –≤—Ö–æ–¥",
        };
      }

      return {
        success: false,
        message: data.message || "–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥",
      };
    } catch (error: any) {
      console.error("Verify error:", error);
      return {
        success: false,
        message: error.data?.message || "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞",
      };
    }
  };

  // –í—ã—Ö–æ–¥
  const logout = async (): Promise<void> => {
    try {
      await $fetch("/api/auth/logout", { method: "POST" });
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      user.value = null;
      if (process.client) {
        localStorage.removeItem("chat-user");
        localStorage.removeItem("chat-user-id");
      }
      console.log("‚úÖ User logged out");
      await navigateTo("/login");
    }
  };

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ä–∞–∑—É
  initAuth();

  return {
    user: readonly(user),
    isAuthenticated,
    login,
    verify,
    logout,
    initAuth,
    checkAuth, // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é
  };
};


useCentrifuge.ts
import { Centrifuge } from "centrifuge";
import { ref, readonly, onUnmounted } from "vue";
import { useMessagesStore } from "~/stores";

interface CentrifugeContext {
  reason?: string;
  [key: string]: any;
}

interface Chat {
  id: string;
  name: string;
  userCount: number;
  lastMessage?: string;
}

export const useCentrifuge = () => {
  const currentUserId = ref("");
  const centrifuge = ref<Centrifuge | null>(null);
  const isConnected = ref(false);
  const connectionError = ref<string>("");
  const reconnectAttempts = ref(0);
  const loadedChats = ref<Chat[]>([]);
  const activeSubscriptions = ref<Map<string, any>>(new Map());
  const isSubscribedToChats = ref(false);

  // –§—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏
  const loadHistory = async (channel: string) => {
    console.log("üîÑ Loading history for channel:", channel);
    try {
      const response = await $fetch("/api/centrifugo/history", {
        method: "POST",
        headers: {
          Authorization:
            "apikey GGMnEv_F6rZjnMQqCousEmqhlOJm0LuodrHnUxfpJRxzqI41u4t-Tjze8Qpk3XFRIwiRd9SB-R_0pcCji1agVA",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          method: "history",
          params: { channel, limit: 100 },
        }),
      });
      console.log("üì¶ History response:", response);
      return response.messages || [];
    } catch (error) {
      console.error("History load error:", error);
      return [];
    }
  };

  // –§—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —á–∞—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const loadUserChats = async (): Promise<Chat[]> => {
    try {
      const response = await $fetch("/api/chats", {
        method: "GET",
      });

      return (response.chats || []).map((chat) => ({
        id: chat.id,
        name: chat.name,
        userCount: chat.userCount || 1,
        lastMessage: chat.lastMessage || "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π",
      }));
    } catch (error) {
      console.error("‚ùå Failed to load user chats:", error);
      return [];
    }
  };

  // –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç
  const addMessagesToChat = (chatId: string, messages: any[]) => {
    const messagesStore = useMessagesStore();

    const processedMessages = messages
      .map((msg) => {
        if (msg.data && msg.data.message) {
          return msg.data.message;
        }
        return msg;
      })
      .filter((msg) => msg && msg.id);

    console.log(
      `‚úÖ Adding ${processedMessages.length} processed messages to chat ${chatId}`,
      processedMessages
    );

    messagesStore.addMessages(chatId, processedMessages);
  };

  // –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞
  const addNewChat = (chat: Chat) => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–≥–æ —á–∞—Ç–∞
    const existingChatIndex = loadedChats.value.findIndex(
      (c) => c.id === chat.id
    );

    if (existingChatIndex === -1) {
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —á–∞—Ç –≤ –Ω–∞—á–∞–ª–æ —Å–ø–∏—Å–∫–∞
      loadedChats.value.unshift(chat);
      console.log(
        `‚úÖ New chat added to loadedChats: ${chat.name} (${chat.id})`
      );

      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞
      subscribeToChatMessages(chat.id);
    } else {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —á–∞—Ç
      loadedChats.value[existingChatIndex] = chat;
      console.log(`‚úÖ Chat updated: ${chat.name} (${chat.id})`);
    }
  };

  // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç–µ
  const updateChatLastMessage = (chatId: string, message: string) => {
    const chat = loadedChats.value.find((c) => c.id === chatId);
    if (chat) {
      chat.lastMessage =
        message.length > 50 ? message.substring(0, 50) + "..." : message;
      console.log(`‚úÖ Last message updated for chat ${chatId}: ${message}`);
    }
  };

  // –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–∞—Ç–∞
  const subscribeToChatMessages = (chatId: string) => {
    if (!centrifuge.value || !isConnected.value) {
      console.log(
        "‚è≥ Not connected yet, subscription will be established after connection"
      );
      return;
    }

    const channel = `chat:${chatId}`;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –ª–∏ —É–∂–µ
    if (activeSubscriptions.value.has(channel)) {
      console.log(`‚ÑπÔ∏è Already subscribed to ${channel}`);
      return;
    }

    try {
      const sub = centrifuge.value.newSubscription(channel);

      sub.on("publication", (ctx: any) => {
        console.log("üì® New real-time message:", ctx.data);
        const messagesStore = useMessagesStore();

        if (ctx.data.message) {
          messagesStore.addMessage(chatId, ctx.data.message);
          updateChatLastMessage(chatId, ctx.data.message.text);
          console.log(
            `‚úÖ Real-time message added to chat ${chatId}:`,
            ctx.data.message
          );
        } else if (ctx.data.data && ctx.data.data.message) {
          messagesStore.addMessage(chatId, ctx.data.data.message);
          updateChatLastMessage(chatId, ctx.data.data.message.text);
          console.log(
            `‚úÖ Real-time message added to chat ${chatId}:`,
            ctx.data.data.message
          );
        }
      });

      sub.on("subscribed", (ctx: any) => {
        console.log(`‚úÖ Successfully subscribed to ${channel}`);
      });

      sub.on("error", (err: any) => {
        console.error(`üí• Subscription error for ${channel}:`, err);
      });

      sub.subscribe();
      activeSubscriptions.value.set(channel, sub);
      console.log(`üéØ Subscribed to chat messages: ${channel}`);
    } catch (error) {
      console.error("Subscription error:", error);
    }
  };

  // –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —á–∞—Ç–æ–≤
  const subscribeToChatsUpdates = () => {
    if (!centrifuge.value || !isConnected.value) {
      console.log(
        "‚è≥ Not connected yet, chats subscription will be established after connection"
      );
      return;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –ª–∏ —É–∂–µ
    if (isSubscribedToChats.value) {
      console.log("‚ÑπÔ∏è Already subscribed to chats updates");
      return;
    }

    const channel = "chats:updates";

    try {
      const sub = centrifuge.value.newSubscription(channel);

      sub.on("publication", (ctx: any) => {
        console.log("üîÑ Chat list update received:", ctx.data);
        if (ctx.data.chat) {
          console.log("üéØ Adding chat from real-time update:", ctx.data.chat);
          addNewChat(ctx.data.chat);
        }
      });

      sub.on("subscribed", (ctx: any) => {
        console.log(`‚úÖ Successfully subscribed to ${channel}`);
        isSubscribedToChats.value = true;
      });

      sub.on("error", (err: any) => {
        console.error(`üí• Subscription error for ${channel}:`, err);
        isSubscribedToChats.value = false;
      });

      sub.subscribe();
      activeSubscriptions.value.set(channel, sub);
      console.log(`üéØ Subscribed to chats updates: ${channel}`);
    } catch (error) {
      console.error("Chats subscription error:", error);
    }
  };

  // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π –ø–æ–¥–ø–∏—Å–æ–∫
  const connect = async (token: string, userId: string): Promise<boolean> => {
    currentUserId.value = userId;

    return new Promise((resolve) => {
      try {
        connectionError.value = "";

        const getWsUrl = (): string => {
          return "wss://mio-messenger.com/connection/websocket";
        };

        const wsUrl = getWsUrl();
        console.log(`üîó Connecting to: ${wsUrl} for user: ${userId}`);

        centrifuge.value = new Centrifuge(wsUrl, {
          token: token,
          debug: true,
          minReconnectDelay: 1000,
          maxReconnectDelay: 10000,
          getToken: async function () {
            console.log(
              "üîÑ Token refresh requested for user:",
              currentUserId.value
            );
            try {
              const { data: tokenData } = await $fetch("/api/token", {
                method: "POST",
                body: { userId: currentUserId.value },
              });

              if (tokenData?.token) {
                console.log("‚úÖ New token received");
                return tokenData.token;
              }
            } catch (error) {
              console.error("‚ùå Failed to refresh token:", error);
            }
            return token;
          },
        });

        centrifuge.value.on("connecting", (ctx: CentrifugeContext) => {
          console.log("üîÑ Connecting to Centrifugo...");
          connectionError.value = "–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è...";
        });

        centrifuge.value.on("connected", async (ctx) => {
          console.log("‚úÖ Connected to Centrifugo!");
          isConnected.value = true;
          connectionError.value = "";
          reconnectAttempts.value = 0;

          // –ó–∞–≥—Ä—É–∂–∞–µ–º —á–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          try {
            const userChats = await loadUserChats();
            loadedChats.value = userChats;
            console.log(
              `üìã Loaded ${userChats.length} chats for user: ${currentUserId.value}`
            );

            // –ü–û–î–ü–ò–°–´–í–ê–ï–ú–°–Ø –ù–ê –û–ë–ù–û–í–õ–ï–ù–ò–Ø –°–ü–ò–°–ö–ê –ß–ê–¢–û–í
            subscribeToChatsUpdates();

            // –î–õ–Ø –ö–ê–ñ–î–û–ì–û –ß–ê–¢–ê: –∑–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
            for (const chat of userChats) {
              // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π
              const messages = await loadHistory(`chat:${chat.id}`);
              console.log(
                `üìú Loaded ${messages.length} messages for chat ${chat.id}`
              );
              addMessagesToChat(chat.id, messages);

              // –ü–û–î–ü–ò–°–´–í–ê–ï–ú–°–Ø –ù–ê –°–û–û–ë–©–ï–ù–ò–Ø –ß–ê–¢–ê
              subscribeToChatMessages(chat.id);
            }
          } catch (error) {
            console.error("‚ùå Failed to load chats history:", error);
          }

          resolve(true);
        });

        centrifuge.value.on("disconnected", (ctx: CentrifugeContext) => {
          console.log("‚ùå Disconnected from Centrifugo:", ctx.reason);
          isConnected.value = false;
          connectionError.value = `–û—Ç–∫–ª—é—á–µ–Ω–æ: ${ctx.reason}`;
          isSubscribedToChats.value = false;

          // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
          setTimeout(() => {
            if (centrifuge.value && !isConnected.value) {
              console.log("üîÑ Auto-reconnecting after disconnect...");
              centrifuge.value.connect();
            }
          }, 2000);
        });

        centrifuge.value.on("error", (err: any) => {
          console.error("üí• Centrifugo error:", err);
          connectionError.value = `–û—à–∏–±–∫–∞: ${err.message}`;
        });

        centrifuge.value.on("reconnecting", (ctx: CentrifugeContext) => {
          reconnectAttempts.value++;
          console.log(
            `üîÑ Reconnecting... (attempt ${reconnectAttempts.value})`
          );
          connectionError.value = `–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ... (–ø–æ–ø—ã—Ç–∫–∞ ${reconnectAttempts.value})`;
        });

        centrifuge.value.connect();

        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        setTimeout(() => {
          if (!isConnected.value) {
            console.log("‚è∞ Connection timeout");
            connectionError.value = "–¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è";
            resolve(false);
          }
        }, 15000);
      } catch (error: any) {
        console.error("Connection setup error:", error);
        connectionError.value = `Setup error: ${error}`;
        resolve(false);
      }
    });
  };

  const subscribe = (channel: string, callback: (data: any) => void) => {
    if (!centrifuge.value || !isConnected.value) {
      console.error("Cannot subscribe - not connected");
      return null;
    }

    try {
      const sub = centrifuge.value.newSubscription(channel);

      sub.on("publication", (ctx: any) => {
        console.log(`üì® Publication on ${channel}:`, ctx.data);
        callback(ctx.data);
      });

      sub.on("subscribed", (ctx: any) => {
        console.log(`‚úÖ Successfully subscribed to ${channel}`);
      });

      sub.on("error", (err: any) => {
        console.error(`üí• Subscription error for ${channel}:`, err);
      });

      sub.subscribe();
      return sub;
    } catch (error) {
      console.error("Subscription error:", error);
      return null;
    }
  };

  const disconnect = () => {
    if (centrifuge.value) {
      // –û—Ç–ø–∏—Å—ã–≤–∞–µ–º—Å—è –æ—Ç –≤—Å–µ—Ö –ø–æ–¥–ø–∏—Å–æ–∫
      activeSubscriptions.value.forEach((sub, channel) => {
        sub.unsubscribe();
        console.log(`üî¥ Unsubscribed from ${channel}`);
      });
      activeSubscriptions.value.clear();
      isSubscribedToChats.value = false;

      centrifuge.value.disconnect();
      centrifuge.value = null;
      isConnected.value = false;
    }
  };

  onUnmounted(() => {
    disconnect();
  });

  return {
    connect,
    subscribe,
    disconnect,
    isConnected: readonly(isConnected),
    connectionError: readonly(connectionError),
    loadedChats,
    loadHistory,
    addNewChat,
    updateChatLastMessage,
    subscribeToChatMessages,
  };
};

login.vue
<script setup lang="ts">
definePageMeta({
  layout: false,
  middleware: "auth",
});

const auth = useAuth();
const router = useRouter();

const step = ref<"phone" | "code">("phone");
const phone = ref("");
const code = ref("");
const phoneError = ref("");
const codeError = ref("");
const message = ref("");
const messageType = ref<"success" | "error">("success");
const loading = ref(false);

// Refs –¥–ª—è –∏–Ω–ø—É—Ç–æ–≤
const phoneInput = ref<HTMLInputElement>();
const codeInput = ref<HTMLInputElement>();

// –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
const validatePhone = (phone: string): boolean => {
  const phoneRegex = /^\d{10,15}$/;
  return phoneRegex.test(phone);
};

// –°–±—Ä–æ—Å —Ñ–æ—Ä–º—ã
const resetForm = () => {
  step.value = "phone";
  code.value = "";
  message.value = "";
  phoneError.value = "";
  codeError.value = "";
};

// –ó–∞–ø—Ä–æ—Å –Ω–æ–≤–æ–≥–æ –∫–æ–¥–∞
const requestNewCode = async () => {
  if (!validatePhone(phone.value)) {
    message.value = "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞";
    messageType.value = "error";
    return;
  }

  loading.value = true;
  message.value = "";

  try {
    const result = await auth.login(phone.value);

    if (result.success) {
      message.value = "–ù–æ–≤—ã–π –∫–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω";
      messageType.value = "success";
      code.value = ""; // –û—á–∏—â–∞–µ–º –ø–æ–ª–µ –∫–æ–¥–∞
    } else {
      message.value = result.message;
      messageType.value = "error";
    }
  } catch (error: any) {
    message.value = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫–æ–¥–∞";
    messageType.value = "error";
    console.error("Request code error:", error);
  } finally {
    loading.value = false;
  }
};

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ä–º—ã
const handleSubmit = async () => {
  phoneError.value = "";
  codeError.value = "";
  message.value = "";
  loading.value = true;

  try {
    if (step.value === "phone") {
      // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
      if (!validatePhone(phone.value)) {
        phoneError.value = "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (10-15 —Ü–∏—Ñ—Ä)";
        return;
      }

      // –ó–∞–ø—Ä–æ—Å –∫–æ–¥–∞
      const result = await auth.login(phone.value);

      if (result.success) {
        step.value = "code";
        message.value = result.message;
        messageType.value = "success";

        // –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ –ø–æ–ª–µ –∫–æ–¥–∞ –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ö–æ–¥–∞
        nextTick(() => {
          codeInput.value?.focus();
        });
      } else {
        message.value = result.message;
        messageType.value = "error";
      }
    } else {
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞
      if (!code.value || code.value.length !== 4) {
        codeError.value = "–í–≤–µ–¥–∏—Ç–µ 4-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥";
        return;
      }

      const result = await auth.verify(phone.value, code.value);

      if (result.success && result.user) {
        message.value = result.message;
        messageType.value = "success";

        // –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
        await new Promise((resolve) => setTimeout(resolve, 1000));

        // –†–µ–¥–∏—Ä–µ–∫—Ç –≤ —á–∞—Ç
        await navigateTo("/chat");
      } else {
        message.value = result.message;
        messageType.value = "error";
      }
    }
  } catch (error: any) {
    message.value = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.";
    messageType.value = "error";
    console.error("Auth error:", error);
  } finally {
    loading.value = false;
  }
};

// –ê–≤—Ç–æ-—Ñ–æ–∫—É—Å –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —à–∞–≥–∞
watch(step, (newStep) => {
  nextTick(() => {
    if (newStep === "phone") {
      phoneInput.value?.focus();
    } else if (newStep === "code") {
      codeInput.value?.focus();
    }
  });
});

// –ê–≤—Ç–æ-—Ñ–æ–∫—É—Å –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
onMounted(() => {
  if (auth.isAuthenticated.value) {
    navigateTo("/chat");
    return;
  }

  // –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ –ø–æ–ª–µ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
  nextTick(() => {
    phoneInput.value?.focus();
  });
});

const formatPhone = (event: Event) => {
  const target = event.target as HTMLInputElement;
  phone.value = target.value.replace(/\D/g, "");
};
</script>

<template>
  <div
    class="min-h-screen flex items-center justify-center p-4 relative overflow-hidden"
  >
    <!-- –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω -->
    <div
      class="absolute inset-0 bg-gradient-rotate animate-gradient-rotate"
    ></div>

    <!-- –ö–æ–Ω—Ç–µ–Ω—Ç -->
    <div
      class="max-w-md w-full bg-white rounded-2xl shadow-xl p-8 relative z-10"
    >
      <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ -->
      <div class="text-center mb-8">
        <h1
          class="text-3xl font-bold text-gray-900 mb-2 flex flex-row w-full justify-center"
        >
          <div class="text-[#C71585]">M</div>
          <div class="text-[#FF1493]">i</div>
          <div class="text-[#FF69B4]">o</div>
        </h1>
        <p class="text-gray-600">Message Input Output</p>
      </div>

      <!-- –§–æ—Ä–º–∞ –≤—Ö–æ–¥–∞ -->
      <form @submit.prevent="handleSubmit" class="space-y-6">
        <!-- –í–≤–æ–¥ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ -->
        <div v-if="step === 'phone'">
          <label
            for="phone"
            class="block text-sm font-medium text-gray-700 mb-2"
          >
            –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞
          </label>
          <input
            ref="phoneInput"
            id="phone"
            v-model="phone"
            type="tel"
            placeholder="79991234567"
            @input="formatPhone"
            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none hover:shadow-md focus:shadow transition-shadow duration-300 focus:ring-1 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            :class="{ 'border-red-500': phoneError }"
            maxlength="15"
            :disabled="loading"
          />
          <p v-if="phoneError" class="mt-2 text-sm text-red-600">
            {{ phoneError }}
          </p>
          <p class="mt-2 text-xs text-gray-500">
            –¢–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã, –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤.
          </p>
        </div>

        <!-- –í–≤–æ–¥ –∫–æ–¥–∞ -->
        <div v-if="step === 'code'">
          <label
            for="code"
            class="block text-sm font-medium text-gray-700 mb-2"
          >
            –ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
          </label>
          <input
            ref="codeInput"
            id="code"
            v-model="code"
            type="text"
            placeholder="1234"
            maxlength="4"
            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-1 hover:shadow-md focus:shadow focus:ring-blue-500 focus:outline-none focus:border-blue-500 transition-colors text-center text-2xl tracking-widest"
            :class="{ 'border-red-500': codeError }"
            :disabled="loading"
          />
          <p v-if="codeError" class="mt-2 text-sm text-red-600">
            {{ codeError }}
          </p>
        </div>

        <!-- –°–æ–æ–±—â–µ–Ω–∏—è -->
        <div
          v-if="message"
          class="p-3 rounded-lg text-sm flex justify-between items-center"
          :class="
            messageType === 'error'
              ? 'bg-red-50 text-red-700'
              : 'bg-green-50 text-green-700'
          "
        >
          <div class="">
            {{ message }}
          </div>
          <div
            @click="requestNewCode"
            class="text-white text-sx text-slate-300 py-1 px-2 bg-gray-300 rounded-md w-fit cursor-pointer hover:bg-gray-400 transition-colors"
            :disabled="loading"
          >
            –ø–µ—Ä–µ–∑–∞–ø—Ä–æ—Å–∏—Ç—å
          </div>
        </div>

        <!-- –ö–Ω–æ–ø–∫–∏ -->
        <div class="space-y-3">
          <button
            type="submit"
            :disabled="loading"
            class="w-full bg-blue-600 text-white py-3 px-4 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors font-medium"
          >
            <span v-if="loading" class="flex items-center justify-center gap-2">
              <svg
                class="animate-spin h-5 w-5 text-white"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
              {{ step === "phone" ? "–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥" : "–í–æ–π—Ç–∏" }}
            </span>
            <span v-else>
              {{ step === "phone" ? "–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥" : "–í–æ–π—Ç–∏" }}
            </span>
          </button>

          <button
            v-if="step === 'code'"
            type="button"
            @click="resetForm"
            class="w-full text-gray-600 py-2 px-4 rounded-lg hover:text-gray-800 transition-colors"
            :disabled="loading"
          >
            ‚Üê –ù–∞–∑–∞–¥ –∫ –≤–≤–æ–¥—É –Ω–æ–º–µ—Ä–∞
          </button>
        </div>
      </form>
    </div>
  </div>
</template>

<style>
.bg-gradient-rotate {
  background: linear-gradient(-45deg, #f0f9ff, #ebd4ff, #dddbff, #f0f9ff);
  background-size: 400% 400%;
}

@keyframes gradient-rotate {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

.animate-gradient-rotate {
  animation: gradient-rotate 6s ease infinite;
}
</style>


chat.vue
<script setup lang="ts">
import { SendHorizontal, CheckCheck, Search, X } from "lucide-vue-next";

definePageMeta({
  middleware: "auth",
});

// Types
interface Chat {
  id: string;
  name: string;
  lastMessage?: string;
  userCount: number;
}

interface Message {
  id: string;
  text: string;
  sender: string;
  timestamp: number;
  chatId: string;
}

interface User {
  id: string;
  phone: string;
  name: string;
}

// Composables
const { connect, isConnected, connectionError, loadedChats, addNewChat } =
  useCentrifuge();
const auth = useAuth();
const messagesStore = useMessagesStore();

// State
const currentUser = computed(() => auth.user?.id || "");
const selectedChat = ref<Chat | null>(null);
const newMessage = ref("");
const messagesContainer = ref<HTMLElement>();
const searchUser = ref("");
const isOpen = ref(false);
const isAuthInitialized = ref(false);
const searchResults = ref<User[]>([]);
const showSearchResults = ref(false);
const searchTimeout = ref<NodeJS.Timeout | null>(null);

// Computed
const currentMessages = computed(() => {
  if (!selectedChat.value) return [];
  return messagesStore.getMessages(selectedChat.value.id);
});

const displayChats = computed(() => {
  return loadedChats.value;
});

// Methods
const initializeChat = async () => {
  try {
    console.log("üîÑ Initializing chat for user:", currentUser.value);

    if (!currentUser.value) {
      console.error("‚ùå No user ID available");
      return;
    }

    const { data: tokenData, error } = await useFetch("/api/token", {
      method: "POST",
      body: { userId: currentUser.value },
    });

    console.log("Token response:", tokenData.value, error.value);

    if (error.value) {
      console.error("‚ùå Token error:", error.value);
      return;
    }

    if (tokenData.value?.token) {
      console.log("‚úÖ Token received, connecting...");
      const connected = await connect(tokenData.value.token, currentUser.value);

      if (connected) {
        console.log("üéâ Successfully connected to Centrifugo!");
        console.log("üìã Current chats:", loadedChats.value);
      } else {
        console.error("‚ùå Failed to connect to Centrifugo");
      }
    } else {
      console.error("‚ùå No token in response");
    }
  } catch (error) {
    console.error("üí• Failed to initialize chat:", error);
  }
};

const updateChatLastMessage = (chatId: string, message: string) => {
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤ loadedChats —á–µ—Ä–µ–∑ composable
  addNewChat({
    id: chatId,
    name: `–ß–∞—Ç ${chatId}`,
    userCount: 1,
    lastMessage:
      message.length > 50 ? message.substring(0, 50) + "..." : message,
  });
};

const handleKeydown = (event: KeyboardEvent) => {
  if (event.key === "Enter") {
    if (event.shiftKey) {
      // Shift+Enter - –ø–æ–∑–≤–æ–ª—è–µ–º –±—Ä–∞—É–∑–µ—Ä—É –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
    } else {
      event.preventDefault();
      sendMessage();
      calculateRows();
    }
  }
};

const textareaRef = ref<HTMLTextAreaElement>();
const textareaRows = ref(1);

const calculateRows = () => {
  if (!textareaRef.value) return 1;
  const textarea = textareaRef.value;
  const lineHeight = 20;
  const padding = 24;
  textarea.style.height = "auto";
  const contentHeight = textarea.scrollHeight - padding;
  const calculatedRows = Math.max(
    1,
    Math.min(6, Math.floor(contentHeight / lineHeight))
  );
  return calculatedRows;
};

watch(newMessage, () => {
  nextTick(() => {
    textareaRows.value = calculateRows();
  });
});

// –ù–û–í–´–ô –ú–ï–¢–û–î: –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const searchUsers = async () => {
  if (!searchUser.value.trim()) {
    searchResults.value = [];
    showSearchResults.value = false;
    return;
  }

  try {
    console.log("üîç Searching users for:", searchUser.value);

    const { data, error } = await useFetch("/api/users", {
      method: "GET",
      query: { phone: searchUser.value },
    });

    if (error.value) {
      console.error("‚ùå Search error:", error.value);
      return;
    }

    if (data.value?.users) {
      searchResults.value = data.value.users;
      showSearchResults.value = true;
      console.log(`‚úÖ Found ${searchResults.value.length} users`);
    }
  } catch (error) {
    console.error("‚ùå Failed to search users:", error);
  }
};

// –ù–û–í–´–ô –ú–ï–¢–û–î: –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –≤ –ø–æ–∏—Å–∫–µ
const handleSearchInput = () => {
  // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–∞—É—Ç
  if (searchTimeout.value) {
    clearTimeout(searchTimeout.value);
  }

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π —Ç–∞–π–º–∞—É—Ç –Ω–∞ 2 —Å–µ–∫—É–Ω–¥—ã
  searchTimeout.value = setTimeout(() => {
    searchUsers();
  }, 2000);
};

// –ù–û–í–´–ô –ú–ï–¢–û–î: –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Ç–∞ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
const createChatWithUser = async (user: User) => {
  const chatId = `${currentUser.value}_${user.id}_${Date.now()}`;
  const newChat: Chat = {
    id: chatId,
    name: `–ß–∞—Ç —Å ${user.phone}`,
    userCount: 2,
    lastMessage: "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π",
  };

  try {
    console.log("üîÑ Creating chat with user:", user);

    // –°–ù–ê–ß–ê–õ–ê –î–û–ë–ê–í–õ–Ø–ï–ú –ß–ê–¢ –õ–û–ö–ê–õ–¨–ù–û - —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –æ—Ç–æ–±—Ä–∞–∑–∏–ª—Å—è
    addNewChat(newChat);
    console.log("‚úÖ Chat added locally, now selecting:", newChat);

    // –í—ã–±–∏—Ä–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π —á–∞—Ç —Å—Ä–∞–∑—É
    selectChat(newChat);

    // –°–∫—Ä—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –∏ –æ—á–∏—â–∞–µ–º –ø–æ–ª–µ
    showSearchResults.value = false;
    searchUser.value = "";

    // –ü–û–¢–û–ú –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    const response = await $fetch("/api/chats", {
      method: "POST",
      body: {
        chat: newChat,
      },
    });

    if (response.success) {
      console.log("‚úÖ Chat created successfully on server:", newChat);
    } else {
      console.error("‚ùå Failed to create chat on server:", response.error);
    }
  } catch (error) {
    console.error("‚ùå Error creating chat on server:", error);
    // –ß–∞—Ç —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ, —Ç–∞–∫ —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞–º–µ—Ç–∏—Ç –æ—à–∏–±–∫–∏
  }
};

const createNewChat = async () => {
  const newChatId = Date.now().toString();
  const newChat: Chat = {
    id: newChatId,
    name: `–ß–∞—Ç ${newChatId}`,
    userCount: 1,
    lastMessage: "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π",
  };

  try {
    console.log("üîÑ Creating new chat:", newChat);

    // –°–ù–ê–ß–ê–õ–ê –î–û–ë–ê–í–õ–Ø–ï–ú –ß–ê–¢ –õ–û–ö–ê–õ–¨–ù–û - —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –æ—Ç–æ–±—Ä–∞–∑–∏–ª—Å—è
    addNewChat(newChat);
    console.log("‚úÖ Chat added locally, now selecting:", newChat);

    // –í—ã–±–∏—Ä–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π —á–∞—Ç —Å—Ä–∞–∑—É
    selectChat(newChat);

    // –ü–û–¢–û–ú –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    const response = await $fetch("/api/chats", {
      method: "POST",
      body: {
        chat: newChat,
      },
    });

    if (response.success) {
      console.log("‚úÖ Chat created successfully on server:", newChat);
    } else {
      console.error("‚ùå Failed to create chat on server:", response.error);
    }
  } catch (error) {
    console.error("‚ùå Error creating chat on server:", error);
    // –ß–∞—Ç —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ, —Ç–∞–∫ —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞–º–µ—Ç–∏—Ç –æ—à–∏–±–∫–∏
  }
};

const selectChat = (chat: Chat) => {
  selectedChat.value = chat;
  console.log("‚úÖ Chat selected:", chat);
  nextTick(() => scrollToBottom());
};

const sendMessage = async () => {
  if (!newMessage.value.trim() || !selectedChat.value || !isConnected.value)
    return;

  const message: Message = {
    id: Date.now().toString(),
    text: newMessage.value,
    sender: currentUser.value,
    timestamp: Date.now(),
    chatId: selectedChat.value.id,
  };

  try {
    const messagesStore = useMessagesStore();
    messagesStore.addMessage(selectedChat.value.id, message);
    updateChatLastMessage(selectedChat.value.id, newMessage.value);
    newMessage.value = "";
    nextTick(() => scrollToBottom());

    await $fetch("/api/centrifugo/publish", {
      method: "POST",
      body: {
        channel: `chat:${selectedChat.value.id}`,
        data: { message },
      },
    });

    console.log("‚úÖ Message sent to server");
  } catch (error) {
    console.error("Failed to send message:", error);
  }
};

const scrollToBottom = () => {
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
  }
};

const formatTime = (timestamp: number) => {
  return new Date(timestamp).toLocaleTimeString("ru-RU", {
    hour: "2-digit",
    minute: "2-digit",
  });
};

// –ó–∞–∫—Ä—ã—Ç–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –æ–±–ª–∞—Å—Ç–∏
const closeSearchResults = () => {
  showSearchResults.value = false;
};

// Watch for loadedChats changes to debug
watch(
  loadedChats,
  (newChats) => {
    console.log("üîÑ loadedChats updated:", newChats);
  },
  { deep: true }
);

onMounted(async () => {
  console.log("üîÑ Chat component mounted");

  const isAuthed = auth.checkAuth();
  console.log("üîç Auth check result:", isAuthed);
  console.log("üîç Auth user:", auth.user);

  if (isAuthed && auth.user?.id) {
    console.log("‚úÖ User authenticated, initializing chat...");
    await initializeChat();
    isAuthInitialized.value = true;
  } else {
    console.error("‚ùå User not authenticated even after check");
    if (process.client) {
      const savedUser = localStorage.getItem("chat-user");
      console.log("üîç Direct localStorage check:", savedUser);
      if (savedUser) {
        console.log("üîÑ Trying to manually restore user from localStorage...");
        try {
          const userData = JSON.parse(savedUser);
          // @ts-ignore
          auth.user = userData;
          console.log("‚úÖ Manually restored user:", userData);
          await initializeChat();
          isAuthInitialized.value = true;
        } catch (error) {
          console.error("‚ùå Failed to manually restore user:", error);
        }
      }
    }
  }
});

watch(currentMessages, () => {
  nextTick(() => scrollToBottom());
});

function clearsearchUser() {
  searchUser.value = "";
  searchResults.value = [];
  showSearchResults.value = false;
}

const items = [
  [
    {
      label: "–ü—É–Ω–∫—Ç 1",
      icon: "i-heroicons-pencil-square",
    },
  ],
];
</script>

<template>
  <div class="min-h-screen bg-gray-100" @click="closeSearchResults">
    <div class="bg-white shadow-sm border-b">
      <div
        class="max-w-6xl mx-auto px-4 py-3 flex justify-between items-center"
      >
        <div>
          <h1 class="text-xl font-bold text-gray-800 text-md flex flex-row">
            <div class="text-[#C71585]">M</div>
            <div class="text-[#FF1493]">i</div>
            <div class="text-[#FF69B4]">o</div>
          </h1>
          <p class="text-sm text-gray-600">
            <span :class="isConnected ? 'text-green-600' : 'text-red-600'">
              {{ isConnected ? "–û–Ω–ª–∞–π–Ω" : "–û—Ñ–ª–∞–π–Ω" }}
            </span>
            <span v-if="connectionError" class="text-xs text-orange-600 ml-2">
              ({{ connectionError }})
            </span>
          </p>
        </div>
        <div class="text-right flex items-center gap-4">
          <p class="text-sm text-gray-600" v-if="auth.user">
            {{ auth.user.phone }}
          </p>
          <p class="text-sm text-red-600" v-else>–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω</p>
          <button
            @click="auth.logout()"
            class="text-sm bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600 transition-colors"
          >
            –í—ã–π—Ç–∏
          </button>
        </div>
      </div>
    </div>

    <div class="max-w-6xl mx-auto p-4">
      <div class="bg-white rounded-lg shadow-lg overflow-hidden">
        <div class="flex h-[calc(100vh-110px)]">
          <!-- Sidebar - –°–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ -->
          <div class="w-1/4 border-r bg-gray-50 flex flex-col">
            <div class="pt-4 px-4 w-full relative">
              <input
                v-model="searchUser"
                @input="handleSearchInput"
                type="text"
                maxlength="25"
                placeholder="–ù–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è..."
                class="w-full pr-7 rounded-lg px-4 py-2 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-colors"
                :disabled="!isConnected"
                @click.stop
              />
              <Search
                class="absolute right-6 top-1/2 transform -translate-y-1 text-gray-400 hover:text-gray-600 cursor-pointer transition-colors"
                v-if="!searchUser"
              />
              <X
                class="absolute right-6 top-1/2 transform -translate-y-[2px] text-gray-400 hover:text-gray-600 cursor-pointer transition-colors"
                :size="20"
                @click="clearsearchUser()"
                v-if="searchUser"
              />

              <!-- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ -->
              <div
                v-if="showSearchResults && searchResults.length > 0"
                class="absolute top-full left-0 right-0 bg-white border border-gray-200 rounded-lg shadow-lg mt-1 max-h-60 overflow-y-auto z-10"
                @click.stop
              >
                <div
                  v-for="user in searchResults"
                  :key="user.id"
                  @click="createChatWithUser(user)"
                  class="px-4 py-3 hover:bg-blue-50 cursor-pointer transition-colors border-b border-gray-100 last:border-b-0"
                >
                  <div class="font-medium text-gray-800">{{ user.phone }}</div>
                  <div class="text-sm text-gray-500">{{ user.name }}</div>
                </div>
              </div>

              <!-- –°–æ–æ–±—â–µ–Ω–∏–µ "–Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ" -->
              <div
                v-if="showSearchResults && searchResults.length === 0"
                class="absolute top-full left-0 right-0 bg-white border border-gray-200 rounded-lg shadow-lg mt-1 z-10"
                @click.stop
              >
                <div class="px-4 py-3 text-gray-500 text-center">
                  –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
                </div>
              </div>
            </div>

            <div class="p-4 border-b">
              <button
                @click="createNewChat"
                class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors flex items-center justify-center gap-2"
                :disabled="!auth.user"
              >
                –ù–æ–≤—ã–π —á–∞—Ç
              </button>
            </div>

            <div class="flex-1 overflow-y-auto">
              <div v-if="!auth.user" class="p-4 text-center text-gray-500">
                –ó–∞–≥—Ä—É–∑–∫–∞...
              </div>
              <div
                v-else-if="displayChats.length === 0"
                class="p-4 text-center text-gray-500"
              >
                –ù–µ—Ç —á–∞—Ç–æ–≤. –°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π —á–∞—Ç!
              </div>
              <div
                v-else
                v-for="chat in displayChats"
                :key="chat.id"
                @click="selectChat(chat)"
                class="px-4 py-4 pr-2 border-b cursor-pointer transition-colors hover:bg-blue-50"
                :class="{
                  'bg-blue-100 border-blue-200': selectedChat?.id === chat.id,
                }"
              >
                <div class="flex flex-row gap-3 justify-between">
                  <div class="flex flex-row gap-3 flex-1 min-w-0">
                    <div class="w-12 flex-shrink-0">
                      <nuxt-img
                        class="w-12 h-12 bg-green-200/50 rounded-full"
                        src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSWAk-mfGdhPFylzhxWsEXqJa6DR5KaCd2ThA&s"
                      />
                    </div>
                    <div class="flex-1 min-w-0">
                      <div class="font-semibold text-gray-800 truncate">
                        {{ chat.name }}
                      </div>
                      <div class="text-sm text-gray-500 truncate mt-1">
                        {{ chat.lastMessage || "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π" }}
                      </div>
                    </div>
                  </div>
                  <div
                    class="w-14 h-full text-sm flex flex-col justify-center pt-1 gap-[3px] text-slate-500 text-right flex-shrink-0"
                  >
                    <div
                      class="flex flex-row gap-1 justify-center items-center text-center"
                    >
                      <CheckCheck :size="15" color="#3b82f6" />
                      <div class="">11:55</div>
                    </div>
                    <div class="">23</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Main Chat Area -->
          <div class="flex-1 flex flex-col">
            <template v-if="selectedChat && auth.user">
              <!-- Messages -->
              <div
                ref="messagesContainer"
                class="flex-1 overflow-y-auto p-4 space-y-1 bg-gray-50"
              >
                <div
                  v-for="message in currentMessages"
                  :key="message.id"
                  class="flex"
                  :class="{ 'justify-end': message.sender === currentUser }"
                >
                  <div
                    class="max-w-xs lg:max-w-md px-3 py-[2px] rounded-2xl shadow-sm"
                    :class="
                      message.sender === currentUser
                        ? 'bg-blue-500 text-white rounded-br-none'
                        : 'bg-white text-gray-800 rounded-bl-none border'
                    "
                  >
                    <div class="flex justify-between">
                      <div class="text-sm">{{ message.text }}</div>
                      <div
                        class="text-xs mt-1.5 pb-[3px] text-right pl-2 flex flex-col justify-end"
                        :class="
                          message.sender === currentUser
                            ? 'text-blue-200'
                            : 'text-gray-400'
                        "
                      >
                        {{ formatTime(message.timestamp) }}
                      </div>
                    </div>
                  </div>
                </div>

                <div
                  v-if="currentMessages.length === 0"
                  class="text-center text-gray-500 flex flex-col h-full justify-center items-center"
                >
                  <div class="text-lg">–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π</div>
                  <div class="text-sm">–ù–∞—á–Ω–∏—Ç–µ –æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–≤—ã–º!</div>
                </div>
              </div>

              <!-- Message Input -->
              <div class="px-4 py-2 border-t bg-white">
                <form
                  @submit.prevent="sendMessage"
                  class="flex gap-2 items-center"
                >
                  <textarea
                    v-model="newMessage"
                    @keydown="handleKeydown"
                    placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..."
                    :rows="textareaRows"
                    class="flex-1 rounded-lg content-center px-4 py-3 border-none outline-none resize-none min-h-[52px] max-h-32 overflow-y-auto"
                    :disabled="!isConnected"
                    ref="textareaRef"
                  />
                  <button
                    type="submit"
                    class="bg-blue-500 text-white px-4 py-3 rounded-lg hover:bg-blue-600 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center gap-2 h-[52px]"
                    :disabled="!newMessage.trim() || !isConnected"
                  >
                    <SendHorizontal :size="20" />
                  </button>
                </form>
              </div>
            </template>

            <!-- No Chat Selected -->
            <div
              v-else
              class="flex-1 flex items-center justify-center text-gray-500"
            >
              <div class="text-center">
                <div class="text-2xl mb-2">üëã</div>
                <div class="text-lg font-semibold" v-if="auth.user">
                  –í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç
                </div>
                <div class="text-lg font-semibold" v-else>–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                <div class="text-sm">–∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –¥–ª—è –Ω–∞—á–∞–ª–∞ –æ–±—â–µ–Ω–∏—è</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>


login.post.ts
// server/api/login.post.ts
import { getRedis } from "../../utils/redis";

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event);
    const { phone } = body;

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (—Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã, 10-15 —Å–∏–º–≤–æ–ª–æ–≤)
    const phoneRegex = /^\d{10,15}$/;
    if (!phone || !phoneRegex.test(phone)) {
      return {
        success: false,
        message:
          "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (—Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã, 10-15 —Å–∏–º–≤–æ–ª–æ–≤)",
      };
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 4-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥
    const code = Math.floor(1000 + Math.random() * 9000).toString();

    // –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∫–æ–¥–æ–≤ (–≤—Å–µ–≥–¥–∞ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫–æ–¥)
    const storage = useStorage("auth");
    await storage.setItem(`code:${phone}`, {
      code,
      phone,
      createdAt: Date.now(),
      attempts: 0,
    });

    console.log(`üîê –ö–æ–¥ –¥–ª—è ${phone}: ${code}`); // –í –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ —É–±—Ä–∞—Ç—å!

    // –°–û–•–†–ê–ù–Ø–ï–ú/–û–ë–ù–û–í–õ–Ø–ï–ú –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø –í REDIS –î–õ–Ø –ü–û–ò–°–ö–ê
    const redis = getRedis();
    const userId = `user-${phone}`; // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userKey = `user:${userId}`;

    try {
      await redis.hset(userKey, {
        id: userId,
        phone: phone,
        name: phone, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–∞–∫ –∏–º—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        createdAt: Date.now().toString(),
      });
      console.log(`‚úÖ User saved to Redis: ${phone} (${userId})`);
    } catch (redisError) {
      console.error("‚ùå Failed to save user to Redis:", redisError);
      // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–∞–∂–µ –µ—Å–ª–∏ Redis –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    }

    return {
      success: true,
      message: `–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ ${phone}`,
      // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –æ—Ç–ø—Ä–∞–≤–∫–∞ SMS
    };
  } catch (error: any) {
    console.error("Login error:", error);
    return {
      success: false,
      message: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞",
    };
  }
});

verify.post.ts
// server/api/verify.post.ts
import { getRedis } from "../../utils/redis";

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event);
    const { phone, code } = body;

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!phone || !code) {
      return {
        success: false,
        message: "–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –∫–æ–¥ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã",
      };
    }

    const storage = useStorage("auth");
    const codeData = await storage.getItem(`code:${phone}`);

    if (!codeData) {
      return {
        success: false,
        message: "–ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É—Å—Ç–∞—Ä–µ–ª. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.",
      };
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø—ã—Ç–∫–∏
    if (codeData.attempts >= 3) {
      await storage.removeItem(`code:${phone}`);
      return {
        success: false,
        message: "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.",
      };
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞ (10 –º–∏–Ω—É—Ç)
    const codeAge = Date.now() - codeData.createdAt;
    if (codeAge > 10 * 60 * 1000) {
      await storage.removeItem(`code:${phone}`);
      return {
        success: false,
        message: "–ö–æ–¥ —É—Å—Ç–∞—Ä–µ–ª. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π.",
      };
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥
    if (codeData.code !== code) {
      // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
      await storage.setItem(`code:${phone}`, {
        ...codeData,
        attempts: codeData.attempts + 1,
      });

      const remainingAttempts = 3 - (codeData.attempts + 1);
      return {
        success: false,
        message: `–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. ${
          remainingAttempts > 0
            ? `–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: ${remainingAttempts}`
            : "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫"
        }`,
      };
    }

    // –ö–æ–¥ –≤–µ—Ä–Ω—ã–π - —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await storage.removeItem(`code:${phone}`);

    const user = {
      id: `user-${phone}`,
      phone: phone,
    };

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
    await storage.setItem(`user:${phone}`, user);

    // –°–û–•–†–ê–ù–Ø–ï–ú –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø –í REDIS –î–õ–Ø –ü–û–ò–°–ö–ê
    const redis = getRedis();
    const userKey = `user:${user.id}`;

    try {
      await redis.hset(userKey, {
        id: user.id,
        phone: user.phone,
        name: user.phone, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–∞–∫ –∏–º—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        createdAt: Date.now().toString(),
      });
      console.log(
        `‚úÖ User saved to Redis for search: ${user.phone} (${user.id})`
      );
    } catch (redisError) {
      console.error("‚ùå Failed to save user to Redis:", redisError);
      // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–∞–∂–µ –µ—Å–ª–∏ Redis –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    }

    return {
      success: true,
      user,
      message: "–£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
    };
  } catch (error: any) {
    console.error("Verify error:", error);
    return {
      success: false,
      message: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞",
    };
  }
});


history.post.ts
// server/api/centrifugo/history.post.ts
import { getRedis } from "../../utils/redis";

export default defineEventHandler(async (event) => {
  const body = await readBody(event);
  const { method, params } = body;

  if (method !== "history") {
    throw createError({ statusCode: 400, message: "Method must be 'history'" });
  }

  const { channel, limit = 50 } = params || {};

  if (!channel) {
    throw createError({ statusCode: 400, message: "Channel is required" });
  }

  const redis = getRedis();
  const streamKey = `centrifugo.stream.${channel}`;

  try {
    const messages = await redis.xrevrange(streamKey, "+", "-", "COUNT", limit);

    const parsedMessages = messages.map(([id, fields]) => {
      // –ò—â–µ–º –ø–æ–ª–µ "data" –≤ –º–∞—Å—Å–∏–≤–µ [key1, value1, key2, value2, ...]
      let dataField = null;
      for (let i = 0; i < fields.length; i += 2) {
        if (fields[i] === "data") {
          dataField = fields[i + 1];
          break;
        }
      }

      let data = null;
      if (dataField) {
        try {
          data = JSON.parse(dataField);
        } catch (e) {
          console.error("‚ùå Failed to parse message data:", dataField, e);
          data = { error: "Invalid JSON", raw: dataField };
        }
      }

      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
      return {
        id,
        data: data || {}, // –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        ...(data?.message || {}), // –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º message –µ—Å–ª–∏ –µ—Å—Ç—å
      };
    });

    const validMessages = parsedMessages.filter(
      (msg) => msg && msg.id && msg.timestamp && !isNaN(msg.timestamp)
    );

    return {
      messages: validMessages.reverse(),
      count: validMessages.length,
    };
  } catch (err) {
    console.error("‚ùå Redis history load error:", err);
    throw createError({
      statusCode: 500,
      message: "Failed to load messages from Redis",
    });
  }
});

publish.post.ts
// server/api/centrifugo/publish.post.ts
import { getRedis } from "../../utils/redis";

export default defineEventHandler(async (event) => {
  const body = await readBody(event);
  const { channel, data } = body;

  if (!channel) {
    throw createError({ statusCode: 400, message: "Channel is required" });
  }

  const redis = getRedis();
  const streamKey = `centrifugo.stream.${channel}`;

  try {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Redis
    const messageId = await redis.xadd(
      streamKey,
      "*",
      "data",
      JSON.stringify(data)
    );

    console.log(`‚úÖ Message saved to Redis: ${channel}, id: ${messageId}`);

    // –ü—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ Centrifugo, –Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫
    try {
      const apiKey =
        "GGMnEv_F6rZjnMQqCousEmqhlOJm0LuodrHnUxfpJRxzqI41u4t-Tjze8Qpk3XFRIwiRd9SB-R_0pcCji1agVA";

      // –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ—Ç –∂–µ —Ö–æ—Å—Ç —á—Ç–æ –∏ –¥–ª—è WebSocket
      const centrifugoResponse = await $fetch("http://localhost:8000/api", {
        method: "POST",
        headers: {
          Authorization: `apikey ${apiKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          method: "publish",
          params: {
            channel: channel,
            data: data,
          },
        }),
      });

      console.log("‚úÖ Centrifugo publish success:", centrifugoResponse);

      return {
        success: true,
        redisId: messageId,
        centrifugo: centrifugoResponse,
      };
    } catch (centrifugoError) {
      console.error(
        "‚ùå Centrifugo publish failed, but message saved to Redis:",
        centrifugoError
      );

      // –í—Å–µ —Ä–∞–≤–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—Ö, —Ç.–∫. —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ Redis
      return {
        success: true,
        redisId: messageId,
        centrifugo: { error: "Centrifugo unavailable, but message saved" },
      };
    }
  } catch (error: any) {
    console.error("‚ùå Publish error:", error);
    throw createError({
      statusCode: 500,
      message: "Failed to publish message",
    });
  }
});


chats.get.ts
// server/api/chats.get.ts
import { getRedis } from "../utils/redis";

export default defineEventHandler(async (event) => {
  const redis = getRedis();

  try {
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —á–∞—Ç—ã –∏–∑ Redis
    const chatKeys = await redis.keys("chat:list:*");
    const chats = [];

    // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª—é—á–∞ —á–∞—Ç–∞ –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    for (const key of chatKeys) {
      const chatData = await redis.hgetall(key);
      if (chatData && chatData.id) {
        chats.push({
          id: chatData.id,
          name: chatData.name || `–ß–∞—Ç ${chatData.id}`,
          userCount: parseInt(chatData.userCount) || 1,
          lastMessage: chatData.lastMessage || "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π",
          createdAt: chatData.createdAt || Date.now().toString(),
        });
      }
    }

    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ —Å–æ–∑–¥–∞–Ω–∏—è (–Ω–æ–≤—ã–µ —Å–≤–µ—Ä—Ö—É)
    chats.sort((a, b) => parseInt(b.createdAt) - parseInt(a.createdAt));

    console.log(`‚úÖ Loaded ${chats.length} chats from Redis`);

    return {
      chats: chats.length > 0 ? chats : getDefaultChats(),
    };
  } catch (error) {
    console.error("‚ùå Failed to load chats from Redis:", error);
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    return {
      chats: getDefaultChats(),
    };
  }
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —á–∞—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
function getDefaultChats() {
  return [
    // {
    //   id: "1111",
    //   name: "–û–±—â–∏–π —á–∞—Ç",
    //   userCount: 3,
    //   lastMessage: "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!",
    // },
    // {
    //   id: "2222",
    //   name: "–¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞",
    //   userCount: 2,
    //   lastMessage: "–ß–µ–º –º–æ–∂–µ–º –ø–æ–º–æ—á—å?",
    // },
    // {
    //   id: "3333",
    //   name: "–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞",
    //   userCount: 5,
    //   lastMessage: "–û–±—Å—É–∂–¥–∞–µ–º –Ω–æ–≤—ã–µ —Ñ–∏—á–∏",
    // },
  ];
}

chats.post.ts
// server/api/chats.post.ts
import { getRedis } from "../utils/redis";

export default defineEventHandler(async (event) => {
  const body = await readBody(event);
  const { chat } = body;

  if (!chat || !chat.id) {
    throw createError({ statusCode: 400, message: "Chat data is required" });
  }

  const redis = getRedis();
  const chatKey = `chat:list:${chat.id}`;

  try {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —á–∞—Ç –≤ Redis
    await redis.hset(chatKey, {
      id: chat.id,
      name: chat.name,
      userCount: chat.userCount || 1,
      lastMessage: chat.lastMessage || "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π",
      createdAt: Date.now().toString(),
    });

    console.log(`‚úÖ Chat saved to Redis: ${chat.name} (${chat.id})`);

    // –ü—É–±–ª–∏–∫—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Centrifugo
    try {
      const apiKey =
        "GGMnEv_F6rZjnMQqCousEmqhlOJm0LuodrHnUxfpJRxzqI41u4t-Tjze8Qpk3XFRIwiRd9SB-R_0pcCji1agVA";

      const centrifugoResponse = await $fetch("http://localhost:8000/api", {
        method: "POST",
        headers: {
          Authorization: `apikey ${apiKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          method: "publish",
          params: {
            channel: "chats:updates",
            data: {
              chat: {
                id: chat.id,
                name: chat.name,
                userCount: chat.userCount || 1,
                lastMessage: chat.lastMessage || "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π",
              },
              action: "created",
              timestamp: Date.now(),
            },
          },
        }),
      });

      console.log(
        "‚úÖ Chat update published to Centrifugo:",
        centrifugoResponse
      );
    } catch (centrifugoError) {
      console.error(
        "‚ùå Centrifugo publish failed, but chat saved:",
        centrifugoError
      );
    }

    return {
      success: true,
      chat: chat,
    };
  } catch (error: any) {
    console.error("‚ùå Chat creation error:", error);
    throw createError({
      statusCode: 500,
      message: "Failed to create chat",
    });
  }
});

token.post.ts
export default defineEventHandler(async (event) => {
  try {
    // –¢–µ–ø–µ—Ä—å –ø–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    const authHeader = getHeader(event, "authorization");
    // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ JWT —Ç–æ–∫–µ–Ω–∞
    // –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Ö–æ–¥

    const body = await readBody(event);
    const { userId } = body;

    if (!userId) {
      return {
        error: "User ID is required",
        success: false,
      };
    }

    const secret =
      "9hfBoHP9HujBtnKoc-KMEDFnTCmPWfjZxCoHacagiI0HLcOww503Qz64tZrstfKD-foGBGeUdoQ8_lyt";

    const { createHmac } = await import("node:crypto");

    // 10 –ª–µ—Ç –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    const oneDayInSeconds = 1 * 1 * 24 * 60 * 60; // 1 –¥–µ–Ω—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö

    const header = { alg: "HS256", typ: "JWT" };
    const payload = {
      sub: userId,
      exp: Math.floor(Date.now() / 1000) + oneDayInSeconds,
    };

    const encodedHeader = Buffer.from(JSON.stringify(header)).toString(
      "base64url"
    );
    const encodedPayload = Buffer.from(JSON.stringify(payload)).toString(
      "base64url"
    );

    const signature = createHmac("sha256", secret)
      .update(encodedHeader + "." + encodedPayload)
      .digest("base64url");

    const token = encodedHeader + "." + encodedPayload + "." + signature;

    return {
      token,
      success: true,
    };
  } catch (error: any) {
    console.error("Token generation error:", error);
    return {
      error: error.message,
      success: false,
    };
  }
});


users.get.ts
// server/api/users.get.ts
import { getRedis } from "../utils/redis";

export default defineEventHandler(async (event) => {
  const query = getQuery(event);
  const { phone } = query;

  if (!phone) {
    throw createError({
      statusCode: 400,
      message: "Phone parameter is required",
    });
  }

  const redis = getRedis();

  try {
    // –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ —á–∞—Å—Ç–∏ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞
    const userKeys = await redis.keys("user:*");
    const foundUsers = [];

    for (const key of userKeys) {
      const userData = await redis.hgetall(key);
      if (
        userData &&
        userData.phone &&
        userData.phone.includes(phone as string)
      ) {
        foundUsers.push({
          id: userData.id,
          phone: userData.phone,
          name: userData.name || userData.phone,
        });
      }
    }

    console.log(`üîç Found ${foundUsers.length} users for phone: ${phone}`);

    return {
      users: foundUsers,
    };
  } catch (error) {
    console.error("‚ùå Failed to search users:", error);
    throw createError({
      statusCode: 500,
      message: "Failed to search users",
    });
  }
});


redis.ts
import Redis from "ioredis";

let redis;

export const getRedis = () => {
  if (!redis) {
    redis = new Redis({
      host: "127.0.0.1", // ‚Üê –ò–°–ü–†–ê–í–¨ –ó–î–ï–°–¨
      port: 6379,
      password: "",
      db: 0,
    });
  }
  return redis;
};


–≤ –∫–∞–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö –∏ —á—Ç–æ –Ω—É–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å ?
—Ü–µ–ª—å: –µ—Å–ª–∏ —è —Å–æ–∑–¥–∞—é 10 —á–∞—Ç–æ–≤ –Ω–∞ —Å–≤–æ—ë–º –ø—Ä–æ—Ñ–∏–ª–µ, —Ç–æ —ç—Ç–∏—Ö —á–∞—Ç–æ–≤ –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å—Å—è –Ω–∞ –¥—Ä—É–≥–æ–º –ø—Ä–æ—Ñ–∏–ª–µ. –ø—Ä–∏ —ç—Ç–æ–º, –µ—Å–ª–∏ —è —Å –æ–¥–Ω–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è –Ω–∞–π–¥—É –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –Ω–∞–ø–∏—à—É –µ–º—É —Å–æ–æ–±—â–µ–Ω–∏–µ - —ç—Ç–æ—Ç —á–∞—Ç —É –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–µ–Ω —Å–æ–∑–¥–∞—Å—Ç—å—Å—è.

–¥—Ä—É–≥–æ–≥–æ –Ω–∏ —á–µ–≥–æ –Ω–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–π.

—Å–∫–∞–∂–∏ —Ñ–∞–π–ª—ã –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏.

–ø—Ä–∏—Å—ã–ª–∞–π —Ü–µ–ª–∏–∫–æ–º —Å–Ω–∞—á–∞–ª–∞ –≤—Å–µ —Ñ–∞–π–ª—ã —Å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º, –∞ –Ω–∏–∂–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —á–∞—Å—Ç–∏ –∫–æ–¥–∞ —Ç–æ–≥–æ, —á—Ç–æ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–ª.

–Ω–∞—á–∏–Ω–∞–π.


